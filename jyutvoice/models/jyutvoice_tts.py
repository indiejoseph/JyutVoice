import os
import math
import datetime as dt
import random
import torch
from torch.nn import functional as F
from jyutvoice.utils.model import (
    sequence_mask,
    generate_path,
    duration_loss,
)
import jyutvoice.utils.monotonic_align as monotonic_align
from jyutvoice.models.baselightningmodule import BaseLightningClass


class JyutVoiceTTS(BaseLightningClass):
    def __init__(
        self,
        encoder,
        decoder,
        output_size=80,
        spk_embed_dim=192,
        freeze_decoder=False,
        use_precomputed_durations=False,
        optimizer=None,
        scheduler=None,
        pretrain_path=None,
        warmup_steps=100,
    ):
        super().__init__()

        self.save_hyperparameters(logger=False)

        self.encoder = encoder
        self.decoder = decoder
        self.use_precomputed_durations = use_precomputed_durations
        self.n_feats = encoder.n_feats
        self.spk_embed_affine_layer = torch.nn.Linear(spk_embed_dim, output_size)

        if freeze_decoder:
            self._freeze_decoder()

        # Load pretrained weights if provided
        if pretrain_path:
            self.load_pretrain(pretrain_path)

    def _freeze_decoder(self):
        for param in self.decoder.parameters():
            param.requires_grad = False
        for param in self.spk_embed_affine_layer.parameters():
            param.requires_grad = False
        self.decoder.eval()
        self.spk_embed_affine_layer.eval()

    def load_pretrain(self, pretrain_path):
        """
        Load pretrained weights from a checkpoint file.

        This method loads weights for transfer learning. It supports:
        1. Loading full model state_dict (encoder + decoder + speaker embedding layer)
        2. Partial loading with strict=False to handle missing keys gracefully
        3. Logging of loaded and skipped weights for debugging

        Args:
            pretrain_path (str): Path to the pretrained checkpoint file (.pt)

        Example:
            >>> model = JyutVoiceTTS(...)
            >>> model.load_pretrain('pretrained_models/pretrain.pt')
        """
        if not os.path.exists(pretrain_path):
            raise FileNotFoundError(f"Pretrain checkpoint not found: {pretrain_path}")

        # Load the checkpoint
        checkpoint = torch.load(pretrain_path, map_location="cpu")

        # Handle both full checkpoints and state_dict-only checkpoints
        if isinstance(checkpoint, dict) and "state_dict" in checkpoint:
            state_dict = checkpoint["state_dict"]
        else:
            state_dict = checkpoint

        # Load the state dict with strict=False to allow for some missing keys
        # (e.g., keys that might be specific to training setup)
        incompatible_keys = self.load_state_dict(state_dict, strict=False)

        return incompatible_keys

    @torch.inference_mode()
    def synthesise(
        self,
        x,
        x_lengths,
        lang,
        tone,
        word_pos,
        syllable_pos,
        spk_embed,
        n_timesteps=10,
        temperature=1.0,
        length_scale=1.0,
    ):
        """
        Generates mel-spectrogram from text. Returns:
            1. encoder outputs
            2. decoder outputs
            3. generated alignment

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            lang (torch.Tensor): language tokens.
                shape: (batch_size, max_text_length)
            tone (torch.Tensor): tone tokens.
                shape: (batch_size, max_text_length)
            word_pos (torch.Tensor): word position tokens.
                shape: (batch_size, max_text_length)
            syllable_pos (torch.Tensor): syllable position tokens.
                shape: (batch_size, max_text_length)
            n_timesteps (int): number of steps to use for reverse diffusion in decoder.
            spk_embed (torch.Tensor): speaker embeddings.
                shape: (batch_size, spk_emb_dim)
            temperature (float, optional): controls variance of diffusion. Defaults to 1.0.
            length_scale (float, optional): controls speech pace.
                Increase value to slow down generated speech and vice versa. Defaults to 1.0.

        Returns:
            dict: {
                "encoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Average mel spectrogram generated by the encoder
                "decoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Refined mel spectrogram improved by the CFM
                "attn": torch.Tensor, shape: (batch_size, max_text_length, max_mel_length),
                # Alignment map between text and mel spectrogram
                "mel": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Denormalized mel spectrogram
                "mel_lengths": torch.Tensor, shape: (batch_size,),
                # Lengths of mel spectrograms
                "rtf": float,
                # Real-time factor
            }
        """
        # For RTF computation
        t = dt.datetime.now()

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        mu_x, logw, x_mask = self.encoder(
            x, x_lengths, lang, tone, word_pos, syllable_pos
        )

        w = torch.exp(logw) * x_mask
        w_ceil = torch.ceil(w) * length_scale
        y_lengths = torch.clamp_min(torch.sum(w_ceil, [1, 2]), 1).long()
        y_max_length = y_lengths.max()

        # Using obtained durations `w` construct alignment map `attn`
        y_mask = sequence_mask(y_lengths, y_max_length).unsqueeze(1).to(x_mask.dtype)
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)
        attn = generate_path(w_ceil.squeeze(1), attn_mask.squeeze(1)).unsqueeze(1)

        # Align encoded text and get mu_y
        # attn: (batch, 1, text_len, mel_len) → squeeze → (batch, text_len, mel_len)
        # mu_x: (batch, n_feats, text_len)
        # Compute: (batch, mel_len, text_len) @ (batch, text_len, n_feats) → (batch, mel_len, n_feats)
        # Then transpose to (batch, n_feats, mel_len)
        mu_y = torch.matmul(
            attn.squeeze(1).transpose(1, 2), mu_x.transpose(1, 2)
        ).transpose(1, 2)
        encoder_outputs = mu_y[:, :, :y_max_length]

        # Enforce batch_size=1 for inference (decoder requirement)
        batch_size = x.size(0)
        if batch_size != 1:
            raise ValueError(
                f"synthesise() requires batch_size=1, got batch_size={batch_size}. "
                "Please pass one sample at a time."
            )

        # Project speaker embedding
        spk_embed = F.normalize(spk_embed, dim=1)
        spk_embed = self.spk_embed_affine_layer(spk_embed)

        # Initialize conditioning tensor: (1, n_feats, mel_len)
        # During inference, we don't have prompt/prefix, so use zeros
        cond = torch.zeros_like(mu_y)

        # Decoder forward pass
        decoder_outputs, _ = self.decoder(
            mu=mu_y,
            mask=y_mask,
            spks=spk_embed,
            cond=cond,
            n_timesteps=n_timesteps,
            temperature=temperature,
            streaming=False,
        )
        decoder_outputs = decoder_outputs[:, :, :y_max_length]

        t = (dt.datetime.now() - t).total_seconds()
        rtf = t * 24000 / (decoder_outputs.shape[-1] * 480)

        return {
            "encoder_outputs": encoder_outputs,
            "decoder_outputs": decoder_outputs,
            "attn": attn,
            "mel": decoder_outputs,
            "mel_lengths": y_lengths,
            "rtf": rtf,
        }

    def forward(
        self,
        x,
        x_lengths,
        y,
        y_lengths,
        lang,
        tone,
        word_pos,
        syllable_pos,
        spk_embed,
        decoder_h,
        durations=None,
    ):
        """
        Computes 3 losses:
            1. duration loss: loss between predicted token durations and those extracted by Monotonic Alignment Search (MAS).
            2. prior loss: the loss between the hidden state of CosyVoice2's flow encoder and the output of the text encoder.
            3. flow matching loss: loss between mel-spectrogram and decoder outputs.

        Args:
            x: Input token IDs (B, T_text)
            x_lengths: Lengths of input token sequences (B,)
            y: Target mel-spectrograms (B, n_mel_channels, T_mel)
            y_lengths: Lengths of target mel-spectrograms (B,)
            lang: Language information (B, T_text)
            tone: Tone information (B, T_text)
            word_pos: Word position information (B, T_text)
            syllable_pos: Syllable position information (B, T_text)
            spk_embed,: Speaker embedding (B, spk_embed_dim)
            decoder_h: Hidden states from the flow encoder of CosyVoice2 (B, T_mel, n_feats)
            durations: Optional ground truth durations for teacher forcing
        """

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        mu_x, logw, x_mask = self.encoder(
            x, x_lengths, lang, tone, word_pos, syllable_pos
        )
        y_max_length = y.shape[-1]

        y_mask = sequence_mask(y_lengths, y_max_length).unsqueeze(1).to(x_mask)
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)

        if self.use_precomputed_durations:
            attn = generate_path(durations.squeeze(1), attn_mask.squeeze(1))
        else:
            # Use MAS to find most likely alignment `attn` between text tokens and decoder_h
            # The text encoder is trained to map text → decoder_h space, so align to decoder_h
            with torch.no_grad():
                const = -0.5 * math.log(2 * math.pi) * self.n_feats
                factor = -0.5 * torch.ones(
                    mu_x.shape, dtype=mu_x.dtype, device=mu_x.device
                )
                # Use decoder_h (flow encoder hidden states) for alignment computation
                # decoder_h: (batch, T_text, n_feats) → transpose to (batch, n_feats, T_text)
                h = decoder_h.transpose(1, 2)
                h_square = torch.matmul(factor.transpose(1, 2), (h**2))
                h_mu_double = torch.matmul(2.0 * (factor * mu_x).transpose(1, 2), h)
                mu_square = torch.sum(factor * (mu_x**2), 1).unsqueeze(-1)
                log_prior = h_square - h_mu_double + mu_square + const

                attn = monotonic_align.maximum_path(log_prior, attn_mask.squeeze(1))
                attn = attn.detach()  # b, t_text, T_text (decoder_h_len)

        # Compute loss between predicted log-scaled durations and those obtained from MAS
        # refered to as prior loss in the paper
        logw_ = torch.log(1e-8 + torch.sum(attn.unsqueeze(1), -1)) * x_mask
        dur_loss = duration_loss(logw, logw_, x_lengths)

        # NOTE unified training, static_chunk_size > 0 or = 0
        streaming = True if random.random() < 0.5 else False

        # xvec projection
        spk_embed = F.normalize(spk_embed, dim=1)
        spk_embed = self.spk_embed_affine_layer(spk_embed)

        # get conditions
        conds = torch.zeros(y.shape, device=y.device)
        for i, j in enumerate(y_lengths):
            if random.random() < 0.5:
                continue
            index = random.randint(0, int(0.3 * j))
            conds[i, :, :index] = y[i, :, :index]

        # Align encoded text with mel-spectrogram and get mu_y segment
        mu_y = torch.matmul(attn.transpose(1, 2), mu_x.transpose(1, 2))
        mu_y = mu_y.transpose(1, 2)

        # Compute loss of the decoder
        diff_loss, _ = self.decoder.compute_loss(
            x1=y,
            mask=y_mask,
            mu=mu_y,
            spks=spk_embed,
            cond=conds,
            streaming=streaming,
        )

        # Compute the prior loss: MSE between aligned encoder representations
        # The prior loss trains the text encoder to match the frozen flow encoder representations
        decoder_max_length = decoder_h.shape[1]
        decoder_h_mask = (
            sequence_mask(y_lengths, decoder_max_length).unsqueeze(1).to(mu_y.dtype)
        )
        mu_y_t = mu_y.transpose(1, 2)  # (B, T_mel, n_feats)

        # Compute prior loss comparing aligned representations
        prior_loss = torch.sum(
            0.5
            * ((decoder_h - mu_y_t) ** 2 + math.log(2 * math.pi))
            * decoder_h_mask.squeeze(1).unsqueeze(-1)
        )
        prior_loss = prior_loss / (torch.sum(decoder_h_mask) * self.n_feats)

        return dur_loss, prior_loss, diff_loss, attn
