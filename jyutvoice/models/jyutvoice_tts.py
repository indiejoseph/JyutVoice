import math
import datetime as dt
import torch
import torch.nn as nn
import torch.nn.functional as F
from jyutvoice.utils.model import (
    sequence_mask,
    generate_path,
    duration_loss,
)
import jyutvoice.utils.monotonic_align as monotonic_align
from jyutvoice.models.baselightningmodule import BaseLightningClass


class JyutVoiceTTS(BaseLightningClass):
    def __init__(
        self,
        encoder,
        decoder,
        ref_encoder,
        dp,
        gin_channels,
        mel_channels,
        optimizer=None,
        scheduler=None,
        warmup_steps=200,
    ):
        super().__init__()

        self.encoder = encoder
        self.decoder = decoder
        self.ref_encoder = ref_encoder
        self.dp = dp
        self.mel_channels = mel_channels

        # uncondition input for cfg
        self.fake_speaker = nn.Parameter(torch.zeros(1, gin_channels))
        self.fake_content = nn.Parameter(torch.zeros(1, mel_channels, 1))

        self.cfg_dropout = 0.2

        self.save_hyperparameters(
            logger=False, ignore=["encoder", "decoder", "ref_encoder", "dp"]
        )

    @torch.inference_mode()
    def synthesise(
        self,
        x,
        x_lengths,
        lang,
        tone,
        y=None,
        n_timesteps=10,
        temperature=1.0,
        alpha=1.0,
        length_scale=1.0,
        solver=None,
        cfg=1.0,
    ):
        """
        Generates mel-spectrogram from text. Returns:
            1. encoder outputs
            2. decoder outputs
            3. generated alignment

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
                shape: (batch_size,)
            lang (torch.Tensor): language tokens.
                shape: (batch_size, max_text_length)
            tone (torch.Tensor): tone tokens.
                shape: (batch_size, max_text_length)
            y (torch.Tensor): mel spectrogram of reference audio
                shape: (batch_size, mel_channels, time)
            n_timesteps (int): number of steps to use for reverse diffusion in decoder.
            temperature (float, optional): controls variance of diffusion. Defaults to 1.0.
            length_scale (float, optional): controls speech pace.
                Increase value to slow down generated speech and vice versa. Defaults to 1.0.

        Returns:
            dict: {
                "encoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Average mel spectrogram generated by the encoder
                "decoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Refined mel spectrogram improved by the CFM
                "attn": torch.Tensor, shape: (batch_size, max_text_length, max_mel_length),
                # Alignment map between text and mel spectrogram
                "mel": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Denormalized mel spectrogram
                "mel_lengths": torch.Tensor, shape: (batch_size,),
                # Lengths of mel spectrograms
                "rtf": float,
                # Real-time factor
            }
        """
        # For RTF computation
        t = dt.datetime.now()

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        c = self.ref_encoder(y, None)

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        x, mu_x, x_mask = self.encoder(x, tone, lang, c, x_lengths)
        logw = self.dp(x, x_mask, c)
        w = torch.exp(logw) * x_mask
        w_ceil = torch.ceil(w) * length_scale
        y_lengths = torch.clamp_min(torch.sum(w_ceil, [1, 2]), 1).long()
        y_max_length = y_lengths.max()

        # Using obtained durations `w` construct alignment map `attn`
        y_mask = sequence_mask(y_lengths, y_max_length).unsqueeze(1).to(x_mask.dtype)
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)
        attn = generate_path(w_ceil.squeeze(1), attn_mask.squeeze(1)).unsqueeze(1)

        # Align encoded text and get mu_y
        mu_y = torch.matmul(attn.squeeze(1).transpose(1, 2), mu_x.transpose(1, 2))
        mu_y = mu_y.transpose(1, 2)
        x = torch.matmul(attn.squeeze(1).transpose(1, 2), x.transpose(1, 2))
        x = x.transpose(1, 2)
        mu_y, sfm_params = self.encoder.forward_smooth(x, y_mask)
        encoder_outputs = mu_y[:, :, :y_max_length]

        # Generate sample tracing the probability flow
        # Generate sample tracing the probability flow
        if cfg == 1.0:
            decoder_outputs, tp, sigma_p = self.decoder(
                sfm_params, y_mask, n_timesteps, temperature, alpha, c, solver
            )
        else:
            cfg_kwargs = {"fake_speaker": self.fake_speaker, "cfg_strength": cfg}
            decoder_outputs, tp, sigma_p = self.decoder(
                sfm_params,
                y_mask,
                n_timesteps,
                temperature,
                alpha,
                c,
                solver,
                cfg_kwargs,
            )

        decoder_outputs = decoder_outputs[:, :, :y_max_length]

        t = (dt.datetime.now() - t).total_seconds()
        rtf = t * 24000 / (decoder_outputs.shape[-1] * 480)

        return (
            {
                "encoder_outputs": encoder_outputs,
                "decoder_outputs": decoder_outputs,
                "attn": attn[:, :, :y_max_length],
                "mel": decoder_outputs,
                "mel_lengths": y_lengths,
                "rtf": rtf,
            },
            tp,
            sigma_p,
        )

    def forward(
        self,
        x,
        x_lengths,
        y,
        y_lengths,
        z,
        z_lengths,
        lang,
        tone,
    ):
        """
        Computes 3 losses:
            1. duration loss: loss between predicted token durations and those extracted by Monotonic Alignment Search (MAS).
            2. prior loss: the loss between the hidden state of CosyVoice2's flow encoder and the output of the text encoder.
            3. flow matching loss: loss between mel-spectrogram and decoder outputs.

        Args:
            x: Input token IDs (B, T_text)
            x_lengths: Lengths of input token sequences (B,)
            y: Target mel-spectrograms (B, n_mel_channels, T_mel)
            y_lengths: Lengths of target mel-spectrograms (B,)
            lang: Language information (B, T_text)
            tone: Tone information (B, T_text)
            z (torch.Tensor): batch of sliced mel-spectrograms.
                shape: (batch_size, n_feats, max_mel_length)
            z_lengths (torch.Tensor): lengths of sliced mel-spectrograms in batch.
                shape: (batch_size,)
        """
        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        y_mask = sequence_mask(y_lengths, y.size(2)).unsqueeze(1).to(y.dtype)
        z_mask = sequence_mask(z_lengths, z.size(2)).unsqueeze(1).to(z.dtype)
        cfg_mask = torch.rand(y.size(0), 1, device=y.device) > self.cfg_dropout

        # compute global speaker embedding
        c = self.ref_encoder(
            z, z_mask
        ) * cfg_mask + ~cfg_mask * self.fake_speaker.repeat(z.size(0), 1)

        x, align_x, x_mask = self.encoder(x, tone, lang, c, x_lengths)
        logw = self.dp(x, x_mask, c)

        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)

        # Use MAS to find most likely alignment `attn` between text and mel-spectrogram
        with torch.no_grad():
            s_p_sq_r = torch.ones_like(align_x)  # [b, d, t]
            neg_cent1 = torch.sum(
                -0.5 * math.log(2 * math.pi) - torch.zeros_like(align_x),
                [1],
                keepdim=True,
            )
            neg_cent2 = torch.einsum("bdt, bds -> bts", -0.5 * (y**2), s_p_sq_r)
            neg_cent3 = torch.einsum("bdt, bds -> bts", y, (align_x * s_p_sq_r))
            neg_cent4 = torch.sum(-0.5 * (align_x**2) * s_p_sq_r, [1], keepdim=True)
            neg_cent = neg_cent1 + neg_cent2 + neg_cent3 + neg_cent4

            attn_mask = torch.unsqueeze(x_mask, 2) * torch.unsqueeze(y_mask, -1)
            attn = (
                monotonic_align.maximum_path(neg_cent, attn_mask.squeeze(1))
                .unsqueeze(1)
                .detach()
            )

        # Compute loss between predicted log-scaled durations and those obtained from MAS
        # refered to as prior loss in the paper
        logw_ = torch.log(1e-8 + attn.sum(2)) * x_mask
        dur_loss = duration_loss(logw, logw_, x_lengths)

        # Align encoded text with mel-spectrogram and get mu_y segment
        attn = attn.squeeze(1).transpose(1, 2)
        align_y = torch.matmul(attn.squeeze(1).transpose(1, 2), align_x.transpose(1, 2))
        align_y = align_y.transpose(1, 2)

        x = torch.matmul(attn.squeeze(1).transpose(1, 2), x.transpose(1, 2))
        x = x.transpose(1, 2)
        mu_y, sfm_params = self.encoder.forward_smooth(x, y_mask)

        # Compute loss of the decoder
        c = c * cfg_mask + ~cfg_mask * self.fake_speaker.repeat(c.size(0), 1)
        loss_dict, value_dict = self.decoder.compute_loss(y, y_mask, sfm_params, c)

        prior_loss = torch.sum(
            0.5 * ((y - align_y) ** 2 + math.log(2 * math.pi)) * y_mask
        )
        prior_loss = prior_loss / (torch.sum(y_mask) * self.mel_channels)

        coarse_loss = F.mse_loss(mu_y, y, reduction="none")
        coarse_loss = torch.sum(coarse_loss) / (torch.sum(y_mask) * self.mel_channels)

        loss_dict["duration_loss"] = dur_loss
        loss_dict["prior_loss"] = prior_loss
        loss_dict["coarse_loss"] = coarse_loss

        return loss_dict, value_dict
